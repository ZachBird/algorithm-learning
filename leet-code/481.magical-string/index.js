/**
 * @param {number} n
 * @return {number}
 */
//  我们将相关的字符串分为三类：题目描述的神奇字符串 s 称为“原串”，对 s 进行连续段划分所得的串叫“划分串”，对划分串进行计数的串叫“计数串”。

//  解题的核心思路：由于划分串是对原串的划分，同时计数串又与原串相同，因此可得三类串均只有 1 和 2 两种数值。即可知划分串的每段长度只能是「长度为 1」或「长度为 2」，利用划分串的每段构造长度有限，我们可以通过「简单分情况讨论」的方式进行构造。

//  具体的，我们需要利用「原串和计数串的相同的性质」对 s 进行构造：不难发现计数串总是不长于原串，因此我们可以使用变量 i 来记录当前构造到原串位置，使用变量 j 来记录计数串对应到的实际位置。

//  不失一般性假设当前构造到 s 中的某一位为 last，而计数串对应的实际位置为 t，由于两者均只有 1 和 2 两种可能，我们可以对其进行简单的分情况讨论（可见代码注释）。

// 原字串 1221121221221121122
// 划分串 1 22 11 2 1 22 1 22 11 2 11 22
// 计数串 1 2  2  1 1 2  1 2  2  1 2  2
const magicalString = function (n) {
  // 模拟，双指针
  let str = '01';
  const countArr = new Array(n + 10).fill(0);
  for (let i = 1, j = 1, cnt = 0; j <= n; ++i) {
    // 当前遍历到的计数串的值 - 确定后续追加长度
    const cur = str[i];
    // 当前模拟串最后一位 - 确定后续追加内容
    const last = str[str.length - 1];
    if (last === '1') {
      if (cur === '1') {
        str += '2';
        countArr[j++] = ++cnt;
      } else {
        str += '12';
        countArr[j] = ++cnt;
        countArr[j + 1] = ++cnt;
        j += 2;
      }
    } else {
      if (cur === '1') {
        str += '1';
        countArr[j++] = cnt;
      } else {
        str += '21';
        countArr[j] = cnt;
        countArr[j + 1] = cnt;
        j += 2;
      }
    }
  }
  return countArr[n];
};
